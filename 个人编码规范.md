###**1.头文件**
####1.1 #pragma once 保护
#####所有头文件都应该使用 #pragma once 保护，防止重定义

####1.2 头文件依赖
#####能用前置声明的地方尽量不使用 *#include*
#####当一个头文件被包含的同时也引入了新的依赖, 一旦该头文件被修改, 代码就会被重新编译. 如果这个头文件又包含了其他头文件, 这些头文件的任何改变都将导致所有包含了该头文件的代码被重新编译. 因此, 我们倾向于减少包含头文件, 尤其是在头文件中包含头文件.
#####1>我们可以将数据成员类型声明为 Foo *(现代C++不再建议使用指针，而是使用智能指针) 或 Foo &
#####2>我们可以将函数参数 / 返回值的类型声明为 Foo (但不能定义实现).
#####3>我们可以将静态数据成员的类型声明为 Foo, 因为静态数据成员的定义在类定义之外.


####1.3. 内联函数
#####只有当函数只有 10 行甚至更少时才将其定义为内联函数.

###**2.作用域**
####2.1 命名空间
#####不允许使用 *using namespace* 的方式，防止污染整个命名空间
#####也不允许使用 *using class* 的方式，必须要在使用的过程把整个命名空间以及变量名字写出来

####2.2 嵌套类
#####嵌套类必须要写到类的开始位置，并且必须带有 *private* 声明，不允许设置为公有

####2.3. 非成员函数、静态成员函数和全局函数
#####使用静态成员函数或名字空间内的非成员函数, 杜绝使用全裸的全局函数
#####有时, 把函数的定义同类的实例脱钩是有益的, 甚至是必要的. 这样的函数可以被定义成静态成员, 或是非成员函数. 非成员函数不应依赖于外部变量, 应尽量置于某个名字空间内. 相比单纯为了封装若干不共享任何静态数据的静态成员函数而创建类, 不如使用命名空间.
#####定义在同一编译单元的函数, 被其他编译单元直接调用可能会引入不必要的耦合和链接时依赖; 静态成员函数对此尤其敏感. 可以考虑提取到新类中, 或者将函数置于独立库的名字空间内.

####2.4. 局部变量
#####将函数变量尽可能置于最小作用域内, 并在变量声明时**必须**进行初始化。(**RAII**)
#####C++ 允许在函数的任何位置声明变量. 我们提倡在尽可能小的作用域中声明变量, 离第一次使用越近越好. 这使得代码浏览者更容易定位变量声明的位置, 了解变量的类型和初始值. 特别是，应使用初始化的方式替代声明再赋值, 比如:

####2.5 静态和全局变量
#####禁止使用 *class* 类型的静态或全局变量: 它们会导致很难发现的 *bug* 和不确定的构造和析构函数调用顺序.
#####静态生存周期的对象, 包括全局变量, 静态变量, 静态类成员变量, 以及函数静态变量, 都必须是原生数据类型 (POD : Plain Old Data): 只能是 int, char, float, 和 void, 以及 POD 类型的数组/结构体/指针. 永远不要使用函数返回值初始化静态变量; 不要在多线程代码中使用非 const 的静态变量.
#####不幸的是, 静态变量的构造函数, 析构函数以及初始化操作的调用顺序在 C++ 标准中未明确定义, 甚至每次编译构建都有可能会发生变化, 从而导致难以发现的 bug. 比如, 结束程序时, 某个静态变量已经被析构了, 但代码还在跑 – 其它线程很可能 – 试图访问该变量, 直接导致崩溃.
#####所以, 我们只允许 POD 类型的静态变量. 本条规则完全禁止 vector (使用 C 数组替代), string (使用 const char*), 及其它以任意方式包含或指向类实例的东东, 成为静态变量. 出于同样的理由, 我们不允许用函数返回值来初始化静态变量.

###**3. 类**
####3.1. 构造函数的职责
#####构造函数中只进行那些没什么意义的 (trivial, YuleFox 注: 简单初始化对于程序执行没有实际的逻辑意义, 因为成员变量 “有意义” 的值大多不在构造函数中确定) 初始化, 可能的话, 使用 Init() 方法集中初始化有意义的 (non-trivial) 数据.
#####构造函数如果执行复杂的函数，会造成以下结果
#####1>构造函数中很难上报错误, 不能使用异常.
#####2>操作失败会造成对象初始化失败，进入不确定状态.
#####3>如果在构造函数内调用了自身的虚函数, 这类调用是不会重定向到子类的虚函数实现. 即使当前没有子类化实现, 将来仍是隐患.
#####4>如果有人创建该类型的全局变量 (虽然违背了上节提到的规则), 构造函数将先 main() 一步被调用, 有可能破坏构造函数中暗含的假设条件. 例如, gflags 尚未初始化.

