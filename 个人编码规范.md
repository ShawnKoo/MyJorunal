###**1.头文件**
####1.1 #pragma once 保护
#####所有头文件都应该使用 #pragma once 保护，防止重定义

####1.2 头文件依赖
#####能用前置声明的地方尽量不使用 *#include*
#####当一个头文件被包含的同时也引入了新的依赖, 一旦该头文件被修改, 代码就会被重新编译. 如果这个头文件又包含了其他头文件, 这些头文件的任何改变都将导致所有包含了该头文件的代码被重新编译. 因此, 我们倾向于减少包含头文件, 尤其是在头文件中包含头文件.<br \>
#####1>我们可以将数据成员类型声明为 Foo *(现代C++不再建议使用指针，而是使用智能指针) 或 Foo &
#####2>我们可以将函数参数 / 返回值的类型声明为 Foo (但不能定义实现).
#####3>我们可以将静态数据成员的类型声明为 Foo, 因为静态数据成员的定义在类定义之外.


####1.3. 内联函数
#####只有当函数只有 10 行甚至更少时才将其定义为内联函数.

###**2.作用域**
####2.1 命名空间
#####不允许使用 *using namespace* 的方式，防止污染整个命名空间
#####也不允许使用 *using class* 的方式，必须要在使用的过程把整个命名空间以及变量名字写出来

####2.2 嵌套类
#####嵌套类必须要写到类的开始位置，并且必须带有 *private* 声明，不允许设置为公有

####2.3. 非成员函数、静态成员函数和全局函数
#####使用静态成员函数或名字空间内的非成员函数, 杜绝使用全裸的全局函数
#####有时, 把函数的定义同类的实例脱钩是有益的, 甚至是必要的. 这样的函数可以被定义成静态成员, 或是非成员函数. 非成员函数不应依赖于外部变量, 应尽量置于某个名字空间内. 相比单纯为了封装若干不共享任何静态数据的静态成员函数而创建类, 不如使用命名空间.
#####定义在同一编译单元的函数, 被其他编译单元直接调用可能会引入不必要的耦合和链接时依赖; 静态成员函数对此尤其敏感. 可以考虑提取到新类中, 或者将函数置于独立库的名字空间内.

####2.4. 局部变量
#####将函数变量尽可能置于最小作用域内, 并在变量声明时**必须**进行初始化。(**RAII**)
#####C++ 允许在函数的任何位置声明变量. 我们提倡在尽可能小的作用域中声明变量, 离第一次使用越近越好. 这使得代码浏览者更容易定位变量声明的位置, 了解变量的类型和初始值. 特别是，应使用初始化的方式替代声明再赋值, 比如:

